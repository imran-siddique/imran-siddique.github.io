<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="Agent OS modules documentation: CMVK (Cross-Model Verification), EMK (Episodic Memory), IATP (Inter-Agent Trust), and AMB (Agent Message Bus).">
    <meta name="keywords" content="CMVK, EMK, IATP, AMB, Agent OS modules, hallucination detection, episodic memory, multi-agent trust, message bus">
    <meta name="author" content="Imran Siddique">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://imran-siddique.github.io/agent-os/modules.html">
    
    <meta property="og:type" content="article">
    <meta property="og:url" content="https://imran-siddique.github.io/agent-os/modules.html">
    <meta property="og:title" content="Modules - Agent OS Documentation">
    
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <title>Modules - Agent OS Documentation | Imran Siddique</title>
    <link rel="stylesheet" href="../styles-new.css">
    <link rel="stylesheet" href="agent-os.css">
</head>
<body>
    <nav class="navbar">
        <div class="container">
            <a href="../index.html" class="logo">Imran Siddique</a>
            <ul class="nav-links">
                <li><a href="../index.html">Home</a></li>
                <li><a href="../about.html">About</a></li>
                <li><a href="../projects.html">Projects</a></li>
                <li><a href="index.html" class="active">Agent OS</a></li>
                <li><a href="../writings.html">Writings</a></li>
                <li><a href="../contact.html">Contact</a></li>
            </ul>
            <div class="hamburger"><span></span><span></span><span></span></div>
        </div>
    </nav>

    <main>
        <section class="docs-hero">
            <div class="container">
                <h1>üß© Modules</h1>
                <p>Modular components for advanced AI governance</p>
            </div>
        </section>

        <section class="docs-content">
            <div class="container">
                <div class="docs-layout">
                    <aside class="docs-sidebar">
                        <nav class="docs-nav">
                            <h4>Modules</h4>
                            <ul>
                                <li><a href="#cmvk">CMVK</a></li>
                                <li><a href="#emk">EMK</a></li>
                                <li><a href="#iatp">IATP</a></li>
                                <li><a href="#amb">AMB</a></li>
                            </ul>
                        </nav>
                        <nav class="docs-nav" style="margin-top: 1rem;">
                            <h4>Documentation</h4>
                            <ul>
                                <li><a href="docs.html">Overview</a></li>
                                <li><a href="quickstart.html">Quickstart</a></li>
                                <li><a href="api.html">API Reference</a></li>
                                <li><a href="policies.html">Policies</a></li>
                                <li><a href="modules.html" class="active">Modules</a></li>
                            </ul>
                        </nav>
                    </aside>

                    <div class="docs-main">
                        <p>Agent OS is built from independent, composable modules. Each module solves a specific problem and can be used standalone or together.</p>

                        <div class="code-block">
                            <pre><code># Install specific modules
pip install agent-os[cmvk]    # Cross-Model Verification
pip install agent-os[emk]     # Episodic Memory
pip install agent-os[iatp]    # Inter-Agent Trust
pip install agent-os[amb]     # Agent Message Bus
pip install agent-os[full]    # Everything</code></pre>
                        </div>

                        <h2 id="cmvk">üîç CMVK - Cross-Model Verification Kernel</h2>
                        <p>Detect hallucinations and verify facts by comparing outputs across multiple LLMs.</p>

                        <h3>The Problem</h3>
                        <p>LLMs can confidently generate false information. A single model's output is unreliable for critical applications.</p>

                        <h3>The Solution</h3>
                        <p>CMVK sends the same query to multiple models and measures semantic agreement. Disagreement flags potential hallucinations.</p>

                        <div class="code-block">
                            <pre><code>from cmvk import verify, ConsensusVerifier, DriftDetector

# Simple semantic comparison
score = verify(
    "The capital of France is Paris.",
    "Paris is the capital city of France."
)
print(f"Drift Score: {score.drift_score}")  # 0.0 = semantically identical
print(f"Agreement: {score.agreement}")       # True

# Multi-model consensus
verifier = ConsensusVerifier(
    models=["gpt-4", "claude-3-sonnet", "gemini-pro"],
    threshold=0.8  # 80% agreement required
)

result = await verifier.verify_consensus(
    prompt="What is the largest planet in our solar system?"
)
print(f"Consensus: {result.agreed}")         # True
print(f"Answer: {result.consensus_answer}")  # "Jupiter"
print(f"Confidence: {result.confidence}")    # 0.95

# Semantic drift detection
detector = DriftDetector()
drift = detector.measure(
    original="The meeting is scheduled for 3pm",
    generated="The meeting starts at 3pm tomorrow"
)
print(f"Drift: {drift.score}")   # 0.15 (small drift)
print(f"Flags: {drift.flags}")   # ["time_modification"]</code></pre>
                        </div>

                        <h3>Key Features</h3>
                        <ul>
                            <li><strong>Semantic Drift Detection</strong> ‚Äî Measure how much meaning has shifted</li>
                            <li><strong>Multi-Model Consensus</strong> ‚Äî Require agreement across 2+ models</li>
                            <li><strong>Hallucination Flagging</strong> ‚Äî Automatic detection of unsupported claims</li>
                            <li><strong>Batch Verification</strong> ‚Äî Verify multiple statements efficiently</li>
                        </ul>

                        <h3>Use Cases</h3>
                        <ul>
                            <li>Fact-checking agent outputs before action</li>
                            <li>Detecting hallucinated citations or references</li>
                            <li>Validating code generation accuracy</li>
                            <li>Quality assurance for content generation</li>
                        </ul>

                        <hr style="margin: 3rem 0; border-color: var(--border-color);">

                        <h2 id="emk">üß† EMK - Episodic Memory Kernel</h2>
                        <p>Immutable, append-only memory for agents with semantic search and time-travel debugging.</p>

                        <h3>The Problem</h3>
                        <p>Agents need persistent memory to learn from experience, but that memory must be tamper-proof for audit and debugging.</p>

                        <h3>The Solution</h3>
                        <p>EMK provides an immutable ledger of agent experiences (episodes) with semantic retrieval and the ability to replay any historical state.</p>

                        <div class="code-block">
                            <pre><code>from emk import Episode, FileAdapter, MemoryStore

# Create a memory store
store = MemoryStore(adapter=FileAdapter("agent_memory.jsonl"))

# Store an episode
episode = Episode(
    goal="Analyze customer data",
    context={"customer_id": "C123", "query_type": "churn_risk"},
    action="SELECT * FROM customers WHERE churn_risk > 0.7",
    result="Found 47 high-risk customers",
    reflection="Query was efficient, but should add time filter",
    success=True
)
store.store(episode)

# Semantic search
similar = store.search(
    query="customer churn analysis",
    limit=5,
    similarity_threshold=0.7
)
for ep in similar:
    print(f"Goal: {ep.goal}, Success: {ep.success}")

# Time-travel: replay to a specific point
snapshot = store.replay(timestamp="2026-01-15T10:00:00Z")
print(f"State at that time: {snapshot}")

# Memory compression (sleep cycle)
store.compress(
    strategy="semantic_dedup",  # Remove near-duplicates
    retention_days=90           # Keep 90 days of detail
)</code></pre>
                        </div>

                        <h3>Episode Structure</h3>
                        <div class="code-block">
                            <pre><code>{
    "id": "ep-abc123",
    "timestamp": "2026-01-15T10:30:00Z",
    "goal": "Analyze customer data",
    "context": {"customer_id": "C123"},
    "action": "SELECT * FROM customers...",
    "result": "Found 47 customers",
    "reflection": "Query was efficient",
    "success": true,
    "checksum": "sha256:def456..."
}</code></pre>
                        </div>

                        <h3>Key Features</h3>
                        <ul>
                            <li><strong>Immutability</strong> ‚Äî Episodes cannot be modified, only appended</li>
                            <li><strong>Semantic Search</strong> ‚Äî Find relevant memories by meaning</li>
                            <li><strong>Time-Travel</strong> ‚Äî Replay agent state at any point</li>
                            <li><strong>Sleep Cycle</strong> ‚Äî Automatic memory compression and deduplication</li>
                            <li><strong>Negative Memory</strong> ‚Äî Learn from failures (anti-patterns)</li>
                        </ul>

                        <hr style="margin: 3rem 0; border-color: var(--border-color);">

                        <h2 id="iatp">ü§ù IATP - Inter-Agent Trust Protocol</h2>
                        <p>Cryptographic identity and message signing for secure multi-agent communication.</p>

                        <h3>The Problem</h3>
                        <p>In multi-agent systems, how do you know a message really came from the agent it claims? How do you prevent impersonation?</p>

                        <h3>The Solution</h3>
                        <p>IATP gives each agent a cryptographic identity. Messages are signed, and recipients verify authenticity before processing.</p>

                        <div class="code-block">
                            <pre><code>from iatp import AgentIdentity, SignedMessage, TrustRegistry, TrustLevel

# Create an agent identity
agent = AgentIdentity.create(
    agent_id="agent-001",
    name="Data Analyzer",
    capabilities=["read_data", "generate_reports", "send_alerts"]
)

# Sign a message
message = SignedMessage.create(
    sender=agent,
    recipient_id="agent-002",
    content={
        "task": "process_data",
        "priority": "high",
        "data_ref": "s3://bucket/data.csv"
    }
)

# Set up trust registry
registry = TrustRegistry()
registry.register(agent, TrustLevel.HIGH)

# Verify incoming message
result = registry.verify(message)
if result.valid:
    print(f"Trusted message from {result.sender_id}")
    print(f"Trust level: {result.trust_level}")
    process_task(result.content)
else:
    print(f"Rejected: {result.reason}")

# Revoke a compromised agent
registry.revoke("agent-001", reason="Suspicious activity detected")

# After revocation, messages from that agent fail verification
result = registry.verify(another_message_from_agent_001)
# result.valid == False, result.reason == "Agent revoked"</code></pre>
                        </div>

                        <h3>Trust Levels</h3>
                        <table>
                            <thead><tr><th>Level</th><th>Description</th><th>Allowed Actions</th></tr></thead>
                            <tbody>
                                <tr><td><code>NONE</code></td><td>Unknown/untrusted</td><td>None</td></tr>
                                <tr><td><code>LOW</code></td><td>Limited trust</td><td>Read-only operations</td></tr>
                                <tr><td><code>MEDIUM</code></td><td>Standard trust</td><td>Most operations</td></tr>
                                <tr><td><code>HIGH</code></td><td>Fully trusted</td><td>All operations</td></tr>
                                <tr><td><code>ADMIN</code></td><td>Administrative</td><td>Registry management</td></tr>
                            </tbody>
                        </table>

                        <h3>Key Features</h3>
                        <ul>
                            <li><strong>Cryptographic Identity</strong> ‚Äî Ed25519 key pairs per agent</li>
                            <li><strong>Message Signing</strong> ‚Äî Tamper-evident communication</li>
                            <li><strong>Trust Levels</strong> ‚Äî Granular permission control</li>
                            <li><strong>Revocation</strong> ‚Äî Instantly revoke compromised agents</li>
                            <li><strong>Capability Attestation</strong> ‚Äî Verify agent capabilities</li>
                        </ul>

                        <hr style="margin: 3rem 0; border-color: var(--border-color);">

                        <h2 id="amb">üì° AMB - Agent Message Bus</h2>
                        <p>Decoupled communication between agents with multiple backend support.</p>

                        <h3>The Problem</h3>
                        <p>Agents need to communicate without tight coupling. Direct function calls don't scale.</p>

                        <h3>The Solution</h3>
                        <p>AMB provides pub/sub messaging with pluggable backends (Redis, Kafka, NATS, SQS).</p>

                        <div class="code-block">
                            <pre><code>from amb_core import MessageBus
from amb_core.adapters import RedisBroker, KafkaBroker, NATSBroker

# Create message bus with Redis backend
broker = RedisBroker(url="redis://localhost:6379")
bus = MessageBus(broker)

# Publish messages
await bus.publish("agent.tasks", {
    "task_id": "task-123",
    "type": "analysis",
    "payload": {"data": "..."}
})

# Subscribe to topics
async def task_handler(message):
    print(f"Received task: {message['task_id']}")
    result = await process_task(message)
    await bus.publish("agent.results", result)

await bus.subscribe("agent.tasks", task_handler)

# Request/reply pattern
response = await bus.request(
    topic="agent.compute",
    message={"operation": "summarize", "text": "..."},
    timeout=30.0
)
print(f"Response: {response}")

# Topic patterns
await bus.subscribe("agent.*.alerts", alert_handler)  # Wildcard
await bus.subscribe("agent.#", audit_handler)         # All agent messages</code></pre>
                        </div>

                        <h3>Available Brokers</h3>
                        <table>
                            <thead><tr><th>Broker</th><th>Best For</th><th>Features</th></tr></thead>
                            <tbody>
                                <tr><td><code>RedisBroker</code></td><td>Low latency</td><td>Pub/sub, streams</td></tr>
                                <tr><td><code>KafkaBroker</code></td><td>High throughput</td><td>Persistence, replay</td></tr>
                                <tr><td><code>NATSBroker</code></td><td>Cloud native</td><td>Lightweight, fast</td></tr>
                                <tr><td><code>SQSBroker</code></td><td>AWS integration</td><td>Managed, scalable</td></tr>
                                <tr><td><code>InMemoryBroker</code></td><td>Testing</td><td>No dependencies</td></tr>
                            </tbody>
                        </table>

                        <h3>Key Features</h3>
                        <ul>
                            <li><strong>Pub/Sub</strong> ‚Äî Publish and subscribe to topics</li>
                            <li><strong>Request/Reply</strong> ‚Äî RPC-style communication</li>
                            <li><strong>Topic Patterns</strong> ‚Äî Wildcards for flexible routing</li>
                            <li><strong>Multiple Backends</strong> ‚Äî Swap backends without code changes</li>
                            <li><strong>Message Serialization</strong> ‚Äî JSON, MessagePack, Protobuf</li>
                        </ul>

                        <h2>Module Independence</h2>
                        <p>Each module is designed to be:</p>
                        <ul>
                            <li><strong>Independent</strong> ‚Äî Use any module standalone</li>
                            <li><strong>Composable</strong> ‚Äî Modules work well together</li>
                            <li><strong>Zero Cross-Dependencies</strong> ‚Äî No module requires another</li>
                        </ul>

                        <div class="code-block">
                            <pre><code># Use modules independently
from cmvk import verify
from emk import MemoryStore
from iatp import TrustRegistry
from amb_core import MessageBus

# Or use everything through the kernel
from agent_os import KernelSpace

kernel = KernelSpace(
    policy="strict",
    cmvk=True,        # Enable verification
    memory=True,      # Enable episodic memory
    trust=True,       # Enable IATP
    message_bus="redis://localhost:6379"
)</code></pre>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <footer>
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h4>Agent OS</h4>
                    <p>Kernel-level governance for autonomous AI agents</p>
                    <p class="footer-version">v1.1.0 | MIT License</p>
                </div>
                <div class="footer-section">
                    <h4>Documentation</h4>
                    <ul>
                        <li><a href="quickstart.html">Quickstart</a></li>
                        <li><a href="api.html">API Reference</a></li>
                        <li><a href="policies.html">Policy Reference</a></li>
                        <li><a href="modules.html">Modules</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Resources</h4>
                    <ul>
                        <li><a href="integrations.html">Integrations</a></li>
                        <li><a href="use-cases.html">Use Cases</a></li>
                        <li><a href="https://github.com/imran-siddique/agent-os" target="_blank">GitHub</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Connect</h4>
                    <ul>
                        <li><a href="https://github.com/imran-siddique" target="_blank">GitHub</a></li>
                        <li><a href="https://linkedin.com/in/imransiddique1986" target="_blank">LinkedIn</a></li>
                    </ul>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2026 Imran Siddique. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="../script.js"></script>
</body>
</html>
