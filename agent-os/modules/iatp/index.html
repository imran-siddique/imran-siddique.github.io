<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="IATP (Inter-Agent Trust Protocol) - Cryptographic identity and message signing for multi-agent AI systems. Prevent impersonation, verify integrity, establish trust chains.">
    <meta name="keywords" content="IATP, Inter-Agent Trust Protocol, Agent OS, Cryptographic Identity, Multi-Agent Systems, Trust Protocol, Message Signing">
    <meta name="author" content="Imran Siddique">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://imran-siddique.github.io/agent-os/modules/iatp/">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://imran-siddique.github.io/agent-os/modules/iatp/">
    <meta property="og:title" content="IATP - Inter-Agent Trust Protocol | Agent OS">
    <meta property="og:description" content="Cryptographic identity and message signing for multi-agent AI systems.">
    <meta property="og:site_name" content="Agent OS">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@mosiddi">
    <meta name="twitter:title" content="IATP - Inter-Agent Trust Protocol">
    <meta name="twitter:description" content="Cryptographic identity for multi-agent AI systems.">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <title>IATP - Inter-Agent Trust Protocol | Agent OS</title>
    <link rel="stylesheet" href="../../../styles-new.css">
    <link rel="stylesheet" href="../../assets/agent-os.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container">
            <a href="../../../index.html" class="logo">Imran Siddique</a>
            <ul class="nav-links">
                <li><a href="../../../index.html">Home</a></li>
                <li><a href="../../../about.html">About</a></li>
                <li><a href="../../../projects.html">Projects</a></li>
                <li><a href="../../index.html" class="active">Agent OS</a></li>
                <li><a href="../../../writings.html">Writings</a></li>
                <li><a href="../../../contact.html">Contact</a></li>
            </ul>
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <main>
        <!-- Hero Section -->
        <section class="aos-docs-hero">
            <div class="container">
                <div class="aos-badge">
                    <span class="pulse-dot"></span>
                    Module Documentation
                </div>
                <h1><span class="gradient">IATP</span></h1>
                <p>Inter-Agent Trust Protocol â€” Cryptographic Identity for Multi-Agent Systems</p>
            </div>
        </section>

        <!-- Documentation Content -->
        <section class="aos-docs-content">
            <div class="container">
                <div class="aos-docs-layout">
                    <!-- Sidebar Navigation -->
                    <aside class="aos-sidebar">
                        <nav class="aos-sidebar-nav">
                            <h4 class="aos-sidebar-title">On This Page</h4>
                            <ul>
                                <li><a href="#what-is-iatp" class="active">What is IATP</a></li>
                                <li><a href="#installation">Installation</a></li>
                                <li><a href="#agent-identity">AgentIdentity Class</a></li>
                                <li><a href="#signed-messages">SignedMessage Class</a></li>
                                <li><a href="#trust-registry">TrustRegistry</a></li>
                                <li><a href="#trust-levels">Trust Levels</a></li>
                                <li><a href="#capability-attestation">Capability Attestation</a></li>
                                <li><a href="#revocation">Revocation & Key Rotation</a></li>
                                <li><a href="#distributed-trust">Distributed Trust Networks</a></li>
                                <li><a href="#kernelspace-integration">KernelSpace Integration</a></li>
                            </ul>
                        </nav>
                        
                        <nav class="aos-sidebar-nav">
                            <h4 class="aos-sidebar-title">Related Modules</h4>
                            <ul>
                                <li><a href="../cmvk/index.html">CMVK</a></li>
                                <li><a href="../emk/index.html">EMK</a></li>
                                <li><a href="../amb/index.html">AMB</a></li>
                            </ul>
                        </nav>
                    </aside>

                    <!-- Main Content -->
                    <div class="aos-main">
                        <!-- What is IATP -->
                        <section id="what-is-iatp">
                            <h2>What is IATP?</h2>
                            <p>
                                The <strong>Inter-Agent Trust Protocol (IATP)</strong> provides cryptographic identity and 
                                message signing for multi-agent AI systems. In environments where multiple agents collaborate, 
                                compete, or delegate tasks, trust is paramount.
                            </p>
                            <p>
                                IATP solves critical security challenges:
                            </p>
                            <ul>
                                <li><strong>Agent Impersonation:</strong> Prevent malicious agents from pretending to be trusted ones</li>
                                <li><strong>Message Integrity:</strong> Ensure messages haven't been tampered with in transit</li>
                                <li><strong>Trust Chains:</strong> Establish verifiable hierarchies of trust between agents</li>
                                <li><strong>Capability Attestation:</strong> Cryptographically prove what an agent is authorized to do</li>
                                <li><strong>Non-repudiation:</strong> Agents cannot deny actions they've signed</li>
                            </ul>
                            
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import AgentIdentity, TrustRegistry

# Create a cryptographic identity for an agent
agent = AgentIdentity.create("finance-agent")

# Sign a message proving authenticity
signed_msg = agent.sign({
    "action": "approve_transaction",
    "amount": 50000,
    "recipient": "vendor-123"
})

# Any agent can verify the signature
is_valid = AgentIdentity.verify(signed_msg)
# is_valid: True</code></pre>
                            </div>
                        </section>

                        <!-- Installation -->
                        <section id="installation">
                            <h2>Installation</h2>
                            <p>Install IATP as a standalone module or as part of the full kernel:</p>
                            
                            <div class="aos-code-block">
                                <pre><code># Standalone installation
pip install agent-os-iatp

# With full kernel
pip install agent-os-kernel[iatp]

# With hardware security module support
pip install agent-os-iatp[hsm]

# With distributed registry support
pip install agent-os-iatp[distributed]</code></pre>
                            </div>
                            
                            <h3>Requirements</h3>
                            <ul>
                                <li>Python 3.9+</li>
                                <li>cryptography >= 41.0.0</li>
                                <li>pynacl >= 1.5.0 (for Ed25519 signatures)</li>
                            </ul>
                        </section>

                        <!-- AgentIdentity Class -->
                        <section id="agent-identity">
                            <h2>AgentIdentity Class</h2>
                            <p>
                                The <code>AgentIdentity</code> class is the core primitive for cryptographic identity. 
                                Each identity consists of a keypair (private + public key) and associated metadata.
                            </p>
                            
                            <h3>Creating an Identity</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import AgentIdentity

# Create a new identity with auto-generated keys
agent = AgentIdentity.create(
    agent_id="research-agent",
    metadata={
        "role": "researcher",
        "department": "R&D",
        "created_by": "system-admin"
    }
)

# Access identity properties
print(agent.agent_id)      # "research-agent"
print(agent.public_key)    # Base64-encoded public key
print(agent.fingerprint)   # SHA256 fingerprint for easy identification</code></pre>
                            </div>
                            
                            <h3>Exporting an Identity</h3>
                            <p>Export identities for storage or transfer. Private keys can be encrypted with a passphrase.</p>
                            <div class="aos-code-block">
                                <pre><code># Export public key only (safe to share)
public_export = agent.export_public()
# {
#     "agent_id": "research-agent",
#     "public_key": "base64...",
#     "fingerprint": "sha256:abc123...",
#     "metadata": {...}
# }

# Export full identity (includes private key - KEEP SECURE!)
full_export = agent.export(
    passphrase="secure-passphrase-here",
    format="pem"  # or "jwk", "raw"
)

# Save to file
agent.save("./identities/research-agent.pem", passphrase="secret")</code></pre>
                            </div>
                            
                            <h3>Importing an Identity</h3>
                            <div class="aos-code-block">
                                <pre><code># Import from exported data
agent = AgentIdentity.from_export(
    export_data,
    passphrase="secure-passphrase-here"
)

# Load from file
agent = AgentIdentity.load(
    "./identities/research-agent.pem",
    passphrase="secret"
)

# Import public key only (for verification)
public_agent = AgentIdentity.from_public_key(
    agent_id="research-agent",
    public_key="base64-encoded-public-key..."
)</code></pre>
                            </div>
                            
                            <h3>Key Algorithms</h3>
                            <p>IATP supports multiple cryptographic algorithms:</p>
                            <table class="aos-table">
                                <thead>
                                    <tr>
                                        <th>Algorithm</th>
                                        <th>Use Case</th>
                                        <th>Key Size</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>ed25519</code></td>
                                        <td>Default, fast signatures</td>
                                        <td>256 bits</td>
                                    </tr>
                                    <tr>
                                        <td><code>rsa-4096</code></td>
                                        <td>Legacy compatibility</td>
                                        <td>4096 bits</td>
                                    </tr>
                                    <tr>
                                        <td><code>ecdsa-p384</code></td>
                                        <td>NIST compliance</td>
                                        <td>384 bits</td>
                                    </tr>
                                </tbody>
                            </table>
                            
                            <div class="aos-code-block">
                                <pre><code># Create identity with specific algorithm
agent = AgentIdentity.create(
    agent_id="compliance-agent",
    algorithm="ecdsa-p384"  # NIST-approved
)</code></pre>
                            </div>
                        </section>

                        <!-- SignedMessage Class -->
                        <section id="signed-messages">
                            <h2>SignedMessage Class</h2>
                            <p>
                                The <code>SignedMessage</code> class represents a cryptographically signed payload. 
                                It bundles the original message, signature, and signer information.
                            </p>
                            
                            <h3>Signing Messages</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import AgentIdentity, SignedMessage

agent = AgentIdentity.create("trading-agent")

# Sign any serializable data
signed = agent.sign({
    "action": "execute_trade",
    "symbol": "AAPL",
    "quantity": 100,
    "price": 150.00,
    "timestamp": "2024-01-15T10:30:00Z"
})

# SignedMessage properties
print(signed.payload)      # Original message
print(signed.signature)    # Base64 signature
print(signed.signer_id)    # "trading-agent"
print(signed.public_key)   # Signer's public key
print(signed.timestamp)    # When it was signed
print(signed.algorithm)    # "ed25519"</code></pre>
                            </div>
                            
                            <h3>Verifying Signatures</h3>
                            <div class="aos-code-block">
                                <pre><code># Method 1: Verify with embedded public key
is_valid = SignedMessage.verify(signed)

# Method 2: Verify against known identity
is_valid = agent.verify_signature(signed)

# Method 3: Verify against TrustRegistry
registry = TrustRegistry()
is_valid, trust_level = registry.verify(signed)

# Comprehensive verification with details
result = SignedMessage.verify_detailed(signed)
# {
#     "valid": True,
#     "signer_id": "trading-agent",
#     "fingerprint": "sha256:abc123...",
#     "signed_at": "2024-01-15T10:30:00Z",
#     "algorithm": "ed25519",
#     "payload_hash": "sha256:def456..."
# }</code></pre>
                            </div>
                            
                            <h3>Message Chaining</h3>
                            <p>Create chains of signed messages for audit trails:</p>
                            <div class="aos-code-block">
                                <pre><code># Agent A initiates a request
agent_a = AgentIdentity.create("requester")
request = agent_a.sign({
    "type": "approval_request",
    "amount": 10000
})

# Agent B approves (chains to original)
agent_b = AgentIdentity.create("approver")
approval = agent_b.sign({
    "type": "approval",
    "original_request": request.to_dict(),
    "decision": "approved"
})

# Verify the entire chain
chain_valid = SignedMessage.verify_chain([request, approval])</code></pre>
                            </div>
                        </section>

                        <!-- TrustRegistry -->
                        <section id="trust-registry">
                            <h2>TrustRegistry</h2>
                            <p>
                                The <code>TrustRegistry</code> manages known agent identities and their trust levels. 
                                It acts as a certificate authority for your multi-agent system.
                            </p>
                            
                            <h3>Creating a Registry</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import TrustRegistry, TrustLevel

# In-memory registry (for development)
registry = TrustRegistry()

# Persistent registry (for production)
registry = TrustRegistry(
    backend="sqlite",
    path="./trust-registry.db"
)

# Distributed registry (for multi-node deployments)
registry = TrustRegistry(
    backend="redis",
    url="redis://localhost:6379",
    namespace="prod-agents"
)</code></pre>
                            </div>
                            
                            <h3>Registering Agents</h3>
                            <div class="aos-code-block">
                                <pre><code># Register an agent with a trust level
agent = AgentIdentity.create("data-processor")

registry.register(
    identity=agent,
    trust_level=TrustLevel.MEDIUM,
    capabilities=["read_data", "process_data"],
    expires_at="2025-01-01T00:00:00Z",  # Optional expiration
    metadata={
        "registered_by": "admin",
        "department": "engineering"
    }
)

# Bulk registration
registry.register_many([
    (agent1, TrustLevel.HIGH, ["admin"]),
    (agent2, TrustLevel.LOW, ["read_only"]),
    (agent3, TrustLevel.MEDIUM, ["read", "write"]),
])</code></pre>
                            </div>
                            
                            <h3>Verifying Against Registry</h3>
                            <div class="aos-code-block">
                                <pre><code># Check if an agent is registered and trusted
is_trusted = registry.is_trusted(agent.fingerprint)

# Get detailed trust information
trust_info = registry.get_trust_info(agent.fingerprint)
# {
#     "agent_id": "data-processor",
#     "trust_level": TrustLevel.MEDIUM,
#     "capabilities": ["read_data", "process_data"],
#     "registered_at": "2024-01-10T...",
#     "expires_at": "2025-01-01T...",
#     "revoked": False
# }

# Verify a signed message with trust context
result = registry.verify_message(signed_message)
# {
#     "signature_valid": True,
#     "signer_trusted": True,
#     "trust_level": TrustLevel.MEDIUM,
#     "has_capability": True  # If capability check requested
# }</code></pre>
                            </div>
                            
                            <h3>Revoking Trust</h3>
                            <div class="aos-code-block">
                                <pre><code># Revoke an agent's trust (e.g., compromised key)
registry.revoke(
    fingerprint=agent.fingerprint,
    reason="Key compromised",
    revoked_by="security-admin"
)

# Check revocation status
is_revoked = registry.is_revoked(agent.fingerprint)

# Get revocation details
revocation = registry.get_revocation(agent.fingerprint)
# {
#     "revoked_at": "2024-01-15T...",
#     "reason": "Key compromised",
#     "revoked_by": "security-admin"
# }</code></pre>
                            </div>
                        </section>

                        <!-- Trust Levels -->
                        <section id="trust-levels">
                            <h2>Trust Levels</h2>
                            <p>
                                IATP defines five trust levels that determine what actions an agent can perform:
                            </p>
                            
                            <table class="aos-table">
                                <thead>
                                    <tr>
                                        <th>Level</th>
                                        <th>Value</th>
                                        <th>Description</th>
                                        <th>Typical Use</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>NONE</code></td>
                                        <td>0</td>
                                        <td>No trust, all actions blocked</td>
                                        <td>Unknown/revoked agents</td>
                                    </tr>
                                    <tr>
                                        <td><code>LOW</code></td>
                                        <td>1</td>
                                        <td>Minimal trust, read-only access</td>
                                        <td>New agents, external systems</td>
                                    </tr>
                                    <tr>
                                        <td><code>MEDIUM</code></td>
                                        <td>2</td>
                                        <td>Standard trust, normal operations</td>
                                        <td>Verified internal agents</td>
                                    </tr>
                                    <tr>
                                        <td><code>HIGH</code></td>
                                        <td>3</td>
                                        <td>Elevated trust, sensitive operations</td>
                                        <td>Core system agents</td>
                                    </tr>
                                    <tr>
                                        <td><code>ADMIN</code></td>
                                        <td>4</td>
                                        <td>Full trust, can modify trust registry</td>
                                        <td>System administrators</td>
                                    </tr>
                                </tbody>
                            </table>
                            
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import TrustLevel

# Compare trust levels
if agent_trust >= TrustLevel.MEDIUM:
    allow_write_access()

# Trust level gates
@registry.require_trust(TrustLevel.HIGH)
async def sensitive_operation(signed_request):
    # Only HIGH or ADMIN trust can execute this
    pass

# Dynamic trust requirements
required_level = TrustLevel.from_action("delete_user")  # Returns HIGH
if registry.get_trust_level(agent) >= required_level:
    proceed_with_action()</code></pre>
                            </div>
                            
                            <h3>Trust Level Policies</h3>
                            <div class="aos-code-block">
                                <pre><code># Define trust policies
policy = TrustPolicy(
    default_level=TrustLevel.LOW,
    action_requirements={
        "read_*": TrustLevel.LOW,
        "write_*": TrustLevel.MEDIUM,
        "delete_*": TrustLevel.HIGH,
        "admin_*": TrustLevel.ADMIN
    },
    auto_elevate=False,  # Require explicit elevation
    require_mfa_above=TrustLevel.HIGH  # MFA for HIGH+
)

registry = TrustRegistry(policy=policy)</code></pre>
                            </div>
                        </section>

                        <!-- Capability Attestation -->
                        <section id="capability-attestation">
                            <h2>Capability Attestation</h2>
                            <p>
                                Capabilities are cryptographically signed tokens that prove an agent is authorized 
                                to perform specific actions. They can be delegated, scoped, and time-limited.
                            </p>
                            
                            <h3>Creating Capabilities</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import Capability, AgentIdentity

# Admin agent creates a capability
admin = AgentIdentity.load("admin.pem", passphrase="...")

capability = Capability.create(
    issuer=admin,
    subject="data-processor",  # Who receives this capability
    actions=["read_customer_data", "process_orders"],
    resources=["customers/*", "orders/*"],
    constraints={
        "max_records": 1000,
        "rate_limit": "100/minute"
    },
    valid_from="2024-01-01T00:00:00Z",
    valid_until="2024-12-31T23:59:59Z",
    delegatable=False  # Cannot be passed to other agents
)</code></pre>
                            </div>
                            
                            <h3>Using Capabilities</h3>
                            <div class="aos-code-block">
                                <pre><code># Agent attaches capability to request
agent = AgentIdentity.create("data-processor")

request = agent.sign({
    "action": "read_customer_data",
    "customer_id": "cust-123"
})

# Attach the capability as proof of authorization
request.attach_capability(capability)

# Verifier checks both signature AND capability
result = registry.verify_authorized(request)
# {
#     "signature_valid": True,
#     "capability_valid": True,
#     "action_authorized": True,
#     "constraints_satisfied": True
# }</code></pre>
                            </div>
                            
                            <h3>Capability Delegation</h3>
                            <div class="aos-code-block">
                                <pre><code># Create a delegatable capability
admin_cap = Capability.create(
    issuer=admin,
    subject="team-lead",
    actions=["read_*", "write_*"],
    delegatable=True,
    max_delegation_depth=2  # Can delegate up to 2 levels deep
)

# Team lead delegates subset to team member
team_lead = AgentIdentity.create("team-lead")
delegated_cap = admin_cap.delegate(
    delegator=team_lead,
    subject="team-member",
    actions=["read_*"],  # Can only delegate subset
    valid_until="2024-06-30T23:59:59Z"  # Cannot exceed parent
)

# Verify delegation chain
chain_valid = Capability.verify_delegation_chain(delegated_cap)</code></pre>
                            </div>
                        </section>

                        <!-- Revocation and Key Rotation -->
                        <section id="revocation">
                            <h2>Revocation and Key Rotation</h2>
                            <p>
                                Security best practices require regular key rotation and the ability to 
                                quickly revoke compromised credentials.
                            </p>
                            
                            <h3>Key Rotation</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import AgentIdentity, TrustRegistry

agent = AgentIdentity.load("agent.pem", passphrase="old-secret")

# Rotate to new key pair
new_agent = agent.rotate_keys(
    new_passphrase="new-secret",
    rotation_proof=True  # Signs new key with old key
)

# Update in registry (maintains trust level and history)
registry.rotate_identity(
    old_fingerprint=agent.fingerprint,
    new_identity=new_agent,
    reason="Scheduled rotation"
)

# Old key is automatically added to revocation list
# but messages signed before rotation remain valid</code></pre>
                            </div>
                            
                            <h3>Automated Rotation Policies</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import RotationPolicy

policy = RotationPolicy(
    max_key_age_days=90,
    warn_before_days=14,
    auto_rotate=True,
    notify_on_rotation=["security@company.com"],
    backup_old_keys=True,
    backup_retention_days=365
)

registry = TrustRegistry(rotation_policy=policy)

# Check rotation status
status = registry.check_rotation_status()
# [
#     {"agent_id": "agent-1", "days_until_rotation": 5, "status": "warning"},
#     {"agent_id": "agent-2", "days_until_rotation": 45, "status": "ok"},
# ]</code></pre>
                            </div>
                            
                            <h3>Emergency Revocation</h3>
                            <div class="aos-code-block">
                                <pre><code># Immediate revocation (compromised key)
registry.revoke_immediately(
    fingerprint=compromised_agent.fingerprint,
    reason="Key compromised - security incident #1234",
    revoked_by="security-team",
    broadcast=True  # Notify all connected registries
)

# Revoke all capabilities issued by this agent
registry.revoke_capabilities_by_issuer(compromised_agent.fingerprint)

# Revoke with grace period (planned decommission)
registry.revoke_scheduled(
    fingerprint=old_agent.fingerprint,
    effective_at="2024-02-01T00:00:00Z",
    reason="Agent decommissioned"
)</code></pre>
                            </div>
                            
                            <h3>Certificate Revocation Lists</h3>
                            <div class="aos-code-block">
                                <pre><code># Get current CRL
crl = registry.get_revocation_list()

# Export CRL for offline verification
crl_data = registry.export_crl(format="json")

# Check against CRL
is_revoked = registry.check_crl(
    fingerprint=agent.fingerprint,
    crl=crl_data
)

# Subscribe to revocation updates
@registry.on_revocation
async def handle_revocation(event):
    print(f"Agent {event.agent_id} was revoked: {event.reason}")
    await invalidate_cached_sessions(event.fingerprint)</code></pre>
                            </div>
                        </section>

                        <!-- Distributed Trust Networks -->
                        <section id="distributed-trust">
                            <h2>Distributed Trust Networks</h2>
                            <p>
                                For large-scale deployments, IATP supports distributed trust networks where 
                                multiple registries can share and synchronize trust information.
                            </p>
                            
                            <h3>Federation Setup</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import TrustRegistry, TrustFederation

# Create local registry
local_registry = TrustRegistry(
    node_id="us-east-1",
    backend="postgres",
    url="postgresql://..."
)

# Join a federation
federation = TrustFederation(
    registries=[
        "https://trust.us-east-1.example.com",
        "https://trust.eu-west-1.example.com",
        "https://trust.ap-south-1.example.com"
    ],
    consensus="majority",  # 2 of 3 must agree
    sync_interval_seconds=30
)

local_registry.join_federation(federation)</code></pre>
                            </div>
                            
                            <h3>Cross-Organization Trust</h3>
                            <div class="aos-code-block">
                                <pre><code># Trust an external organization's registry
local_registry.add_trusted_issuer(
    issuer_id="partner-org",
    public_key="partner-public-key...",
    trust_level=TrustLevel.LOW,  # External agents get LOW by default
    capabilities=["read_shared_data"],
    namespace="partner:*"  # Prefix their agent IDs
)

# Verify message from partner's agent
result = local_registry.verify_message(partner_signed_message)
# {
#     "signature_valid": True,
#     "issuer": "partner-org",
#     "trust_level": TrustLevel.LOW,
#     "namespace": "partner:agent-1"
# }</code></pre>
                            </div>
                            
                            <h3>Trust Gossip Protocol</h3>
                            <div class="aos-code-block">
                                <pre><code># Enable gossip for revocation propagation
local_registry.enable_gossip(
    peers=[
        "registry-node-2:7946",
        "registry-node-3:7946"
    ],
    gossip_interval_ms=500,
    propagation_factor=3
)

# Revocations automatically propagate across network
# within seconds, even in large deployments

# Monitor gossip health
health = local_registry.gossip_health()
# {
#     "connected_peers": 15,
#     "avg_propagation_ms": 120,
#     "last_sync": "2024-01-15T10:30:00Z"
# }</code></pre>
                            </div>
                        </section>

                        <!-- KernelSpace Integration -->
                        <section id="kernelspace-integration">
                            <h2>Integration with KernelSpace</h2>
                            <p>
                                IATP integrates seamlessly with the Agent OS KernelSpace for comprehensive 
                                agent governance including identity verification in policies.
                            </p>
                            
                            <h3>Policy-Based Trust</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os import KernelSpace
                from agent_os.iatp import TrustRegistry, TrustLevel

# Initialize kernel with IATP integration
kernel = KernelSpace(
    trust_registry=TrustRegistry(backend="redis"),
    require_signatures=True,  # All agent actions must be signed
    min_trust_level=TrustLevel.LOW
)

# Define trust-aware policies
kernel.add_policy({
    "name": "financial-operations",
    "rules": [
        {
            "action": "transfer_funds",
            "require": {
                "trust_level": "HIGH",
                "capabilities": ["financial_admin"],
                "signature": "required"
            }
        },
        {
            "action": "view_balance",
            "require": {
                "trust_level": "LOW",
                "signature": "required"
            }
        }
    ]
})</code></pre>
                            </div>
                            
                            <h3>Signed Agent Actions</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.iatp import AgentIdentity

# Agent with identity
agent = AgentIdentity.create("finance-bot")
kernel.register_agent(agent)

@kernel.action("transfer_funds")
async def transfer(request: SignedRequest):
    # Request is automatically verified by kernel
    # Trust level and capabilities are checked
    
    # Access verified identity info
    print(request.signer.agent_id)
    print(request.signer.trust_level)
    print(request.signer.capabilities)
    
    # Perform transfer
    return await execute_transfer(request.payload)

# All actions are automatically signed
result = await kernel.execute(
    agent=agent,
    action="transfer_funds",
    params={"amount": 1000, "to": "vendor-123"}
)</code></pre>
                            </div>
                            
                            <h3>Audit Trail Integration</h3>
                            <div class="aos-code-block">
                                <pre><code># IATP + EMK for complete audit trails
from agent_os.emk import Memory

kernel = KernelSpace(
    trust_registry=TrustRegistry(),
    memory=Memory(immutable=True)
)

# All signed actions are logged with cryptographic proof
# Query audit trail with signature verification
audit_log = await kernel.memory.query(
    filter={"action": "transfer_funds"},
    verify_signatures=True  # Re-verify all signatures
)

for entry in audit_log:
    print(f"{entry.timestamp}: {entry.signer} - {entry.action}")
    print(f"  Signature valid: {entry.signature_valid}")
    print(f"  Trust level at time: {entry.trust_level}")</code></pre>
                            </div>
                            
                            <h3>Complete Multi-Agent Example</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os import KernelSpace
from agent_os.iatp import AgentIdentity, TrustRegistry, TrustLevel, Capability
from agent_os.amb import MessageBus
from agent_os.emk import Memory

# Initialize infrastructure
registry = TrustRegistry(backend="redis")
bus = MessageBus(backend="redis")
memory = Memory(backend="postgres")

kernel = KernelSpace(
    trust_registry=registry,
    message_bus=bus,
    memory=memory,
    policy="strict"
)

# Create agents with identities
coordinator = AgentIdentity.create("coordinator")
worker_1 = AgentIdentity.create("worker-1")
worker_2 = AgentIdentity.create("worker-2")

# Register with trust levels
registry.register(coordinator, TrustLevel.HIGH, ["coordinate", "delegate"])
registry.register(worker_1, TrustLevel.MEDIUM, ["process_data"])
registry.register(worker_2, TrustLevel.MEDIUM, ["process_data"])

# Coordinator delegates work with capability
@kernel.agent(coordinator)
async def coordinate_work(task):
    # Create capability for this specific task
    task_capability = Capability.create(
        issuer=coordinator,
        subject=worker_1.agent_id,
        actions=["process_data"],
        resources=[f"task:{task.id}/*"],
        valid_until=task.deadline
    )
    
    # Send signed task with capability
    await bus.publish(
        topic="tasks",
        message=coordinator.sign({
            "task_id": task.id,
            "data": task.data,
            "capability": task_capability.to_dict()
        })
    )

# Worker processes with verified identity
@kernel.agent(worker_1)
async def process_work(signed_message):
    # Kernel automatically verifies signature and capability
    task = signed_message.payload
    
    result = await process_data(task["data"])
    
    # Sign and return result
    return worker_1.sign({
        "task_id": task["task_id"],
        "result": result,
        "processed_by": worker_1.agent_id
    })

# Run the multi-agent system
await kernel.run()</code></pre>
                            </div>
                        </section>

                        <!-- Next Steps -->
                        <section style="margin-top: var(--space-3xl); padding-top: var(--space-2xl); border-top: 1px solid var(--border-color);">
                            <h2>Next Steps</h2>
                            <div class="aos-docs-grid" style="margin-top: var(--space-lg);">
                                <a href="../amb/index.html" class="aos-doc-card">
                                    <div class="aos-doc-icon">ðŸ“¡</div>
                                    <h3 class="aos-doc-title">AMB Module</h3>
                                    <p class="aos-doc-desc">Agent Message Bus for communication</p>
                                </a>
                                <a href="../emk/index.html" class="aos-doc-card">
                                    <div class="aos-doc-icon">ðŸ§ </div>
                                    <h3 class="aos-doc-title">EMK Module</h3>
                                    <p class="aos-doc-desc">Episodic memory for audit trails</p>
                                </a>
                                <a href="../../docs/api.html" class="aos-doc-card">
                                    <div class="aos-doc-icon">ðŸ“–</div>
                                    <h3 class="aos-doc-title">API Reference</h3>
                                    <p class="aos-doc-desc">Complete IATP API docs</p>
                                </a>
                                <a href="../../examples/index.html" class="aos-doc-card">
                                    <div class="aos-doc-icon">ðŸ’¡</div>
                                    <h3 class="aos-doc-title">Examples</h3>
                                    <p class="aos-doc-desc">Production code samples</p>
                                </a>
                            </div>
                        </section>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="aos-footer">
        <div class="container">
            <div class="aos-footer-grid">
                <div class="aos-footer-brand">
                    <h4>Agent OS</h4>
                    <p>The Linux kernel for AI agents. Deterministic safety enforcement.</p>
                    <p class="aos-footer-version">v0.1.0 â€¢ MIT License</p>
                </div>
                
                <div class="aos-footer-section">
                    <h5>Documentation</h5>
                    <ul>
                        <li><a href="../../docs/quickstart.html">Quickstart</a></li>
                        <li><a href="../../docs/api.html">API Reference</a></li>
                        <li><a href="../../docs/policies.html">Policies</a></li>
                        <li><a href="../index.html">Modules</a></li>
                    </ul>
                </div>
                
                <div class="aos-footer-section">
                    <h5>Resources</h5>
                    <ul>
                        <li><a href="../../integrations/index.html">Integrations</a></li>
                        <li><a href="../../use-cases/index.html">Use Cases</a></li>
                        <li><a href="../../examples/index.html">Examples</a></li>
                        <li><a href="https://github.com/imran-siddique/agent-os" target="_blank">GitHub</a></li>
                    </ul>
                </div>
                
                <div class="aos-footer-section">
                    <h5>Connect</h5>
                    <ul>
                        <li><a href="https://github.com/imran-siddique" target="_blank">GitHub</a></li>
                        <li><a href="https://linkedin.com/in/imransiddique1986" target="_blank">LinkedIn</a></li>
                        <li><a href="https://twitter.com/mosiddi" target="_blank">Twitter</a></li>
                        <li><a href="https://pypi.org/project/agent-os-kernel/" target="_blank">PyPI</a></li>
                    </ul>
                </div>
            </div>
            
            <div class="aos-footer-bottom">
                <p>&copy; 2026 Imran Siddique. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="../../../script.js"></script>
</body>
</html>
