<!DOCTYPE html>
<html lang="en" data-theme="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="EMK (Episodic Memory Kernel) - Immutable agent memory with semantic search, time-travel debugging, and memory compression for AI agents.">
    <meta name="keywords" content="Agent OS, EMK, Episodic Memory Kernel, AI Memory, Semantic Search, Time-Travel Debugging, Agent Memory">
    <meta name="author" content="Imran Siddique">
    <meta name="robots" content="index, follow">
    <link rel="canonical" href="https://imransiddique.com/agent-os-docs-docs/modules/emk/">
    
    <!-- Open Graph -->
    <meta property="og:type" content="website">
    <meta property="og:url" content="https://imransiddique.com/agent-os-docs-docs/modules/emk/">
    <meta property="og:title" content="EMK - Episodic Memory Kernel | Agent OS">
    <meta property="og:description" content="Immutable agent memory with semantic search, time-travel debugging, and memory compression.">
    <meta property="og:site_name" content="Agent OS">
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:site" content="@mosiddi">
    <meta name="twitter:title" content="EMK - Episodic Memory Kernel">
    <meta name="twitter:description" content="Immutable agent memory with semantic search and time-travel debugging.">
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <title>EMK - Episodic Memory Kernel | Agent OS</title>
    <link rel="stylesheet" href="../../../styles-new.css">
    <link rel="stylesheet" href="../../assets/agent-os.css">
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar">
        <div class="container">
            <a href="../../../index.html" class="logo">Imran Siddique</a>
            <ul class="nav-links">
                <li><a href="../../../index.html">Home</a></li>
                <li><a href="../../../about.html">About</a></li>
                <li><a href="../../../projects.html">Projects</a></li>
                <li><a href="../../index.html" class="active">Agent OS</a></li>
                <li><a href="../../../writings.html">Writings</a></li>
                <li><a href="../../../contact.html">Contact</a></li>
            </ul>
            <div class="hamburger">
                <span></span>
                <span></span>
                <span></span>
            </div>
        </div>
    </nav>

    <main>
        <!-- Hero Section -->
        <section class="aos-docs-hero">
            <div class="container">
                <div class="aos-badge">
                    <span class="pulse-dot"></span>
                    Module ‚Ä¢ Memory ‚Ä¢ Auditable
                </div>
                <h1>üß† EMK</h1>
                <p>Episodic Memory Kernel ‚Äî Immutable agent memory with semantic search</p>
            </div>
        </section>

        <!-- Documentation Content -->
        <section class="aos-docs-content">
            <div class="container">
                <div class="aos-docs-layout">
                    <!-- Sidebar Navigation -->
                    <aside class="aos-sidebar">
                        <nav class="aos-sidebar-nav">
                            <h4 class="aos-sidebar-title">On This Page</h4>
                            <ul>
                                <li><a href="#what-is-emk">What is EMK</a></li>
                                <li><a href="#installation">Installation</a></li>
                                <li><a href="#episode-structure">Episode Structure</a></li>
                                <li><a href="#memory-store">MemoryStore</a></li>
                                <li><a href="#semantic-search">Semantic Search</a></li>
                                <li><a href="#time-travel">Time-Travel Debugging</a></li>
                                <li><a href="#memory-compression">Memory Compression</a></li>
                                <li><a href="#negative-memory">Negative Memory</a></li>
                                <li><a href="#storage-backends">Storage Backends</a></li>
                                <li><a href="#kernel-integration">KernelSpace Integration</a></li>
                            </ul>
                        </nav>
                        
                        <nav class="aos-sidebar-nav">
                            <h4 class="aos-sidebar-title">Other Modules</h4>
                            <ul>
                                <li><a href="../cmvk/index.html">CMVK</a></li>
                                <li><a href="../iatp/index.html">IATP</a></li>
                                <li><a href="../amb/index.html">AMB</a></li>
                            </ul>
                        </nav>
                    </aside>

                    <!-- Main Content -->
                    <div class="aos-main">
                        <!-- What is EMK -->
                        <section id="what-is-emk">
                            <h2>What is EMK?</h2>
                            <p>
                                The <strong>Episodic Memory Kernel (EMK)</strong> provides immutable, auditable memory 
                                storage for AI agents. Every action, decision, and outcome is recorded as an 
                                <strong>Episode</strong>‚Äîa structured, tamper-proof record that enables compliance, 
                                debugging, and reproducibility.
                            </p>
                            
                            <p>EMK solves critical challenges in AI agent development:</p>
                            <ul>
                                <li><strong>Audit Trails</strong> ‚Äî Complete history of agent decisions for compliance</li>
                                <li><strong>Debugging</strong> ‚Äî Replay any moment in agent history to diagnose issues</li>
                                <li><strong>Learning</strong> ‚Äî Semantic search enables agents to learn from past experiences</li>
                                <li><strong>Anti-Patterns</strong> ‚Äî Negative memory prevents repeating known mistakes</li>
                            </ul>

                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, Episode

# Create memory for an agent
memory = Memory(agent_id="customer-service-agent")

# Store an episode
episode = Episode(
    goal="Resolve customer complaint #1234",
    action="Issued full refund of $50",
    result="Customer satisfied, case closed",
    reflection="Proactive refunds improve satisfaction scores"
)

await memory.store(episode)

# Later: semantic search for similar situations
similar = await memory.search("customer refund complaint")</code></pre>
                            </div>
                        </section>

                        <!-- Installation -->
                        <section id="installation">
                            <h2>Installation</h2>
                            <p>Install EMK standalone or as part of the full Agent OS kernel:</p>

                            <div class="aos-code-block">
                                <pre><code># Standalone EMK (minimal dependencies)
pip install agent-os-kernel[emk]

# Or with specific backend support
pip install agent-os-kernel[emk,sqlite]   # SQLite backend
pip install agent-os-kernel[emk,postgres] # PostgreSQL backend

# Full kernel (includes all modules)
pip install agent-os-kernel</code></pre>
                            </div>

                            <h3>Requirements</h3>
                            <ul>
                                <li>Python 3.9+</li>
                                <li>Optional: sentence-transformers for semantic search</li>
                                <li>Optional: Database drivers for SQLite/PostgreSQL backends</li>
                            </ul>
                        </section>

                        <!-- Episode Structure -->
                        <section id="episode-structure">
                            <h2>Episode Structure</h2>
                            <p>
                                An <code>Episode</code> is the fundamental unit of memory in EMK. It captures the 
                                complete context of an agent action following the Goal-Action-Result-Reflection pattern.
                            </p>

                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Episode
from datetime import datetime

class Episode:
    """Immutable record of an agent action."""
    
    id: str              # Unique identifier (auto-generated UUID)
    agent_id: str        # ID of the agent that created this episode
    timestamp: datetime  # When the episode was created
    
    # Core GARR fields
    goal: str            # What the agent was trying to achieve
    action: str          # What the agent actually did
    result: str          # What happened (outcome)
    reflection: str      # Agent's analysis of what was learned
    
    # Metadata
    metadata: dict       # Custom key-value pairs
    embedding: list      # Vector embedding for semantic search
    parent_id: str       # Link to parent episode (for chains)
    tags: list[str]      # Categorization tags
    
    # Immutability
    hash: str            # SHA-256 hash for tamper detection
    signature: str       # Optional cryptographic signature</code></pre>
                            </div>

                            <h3>Creating Episodes</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Episode

# Basic episode
episode = Episode(
    goal="Answer user question about pricing",
    action="Retrieved pricing from database, formatted response",
    result="User received accurate pricing information",
    reflection="Database query was efficient, response was well-received"
)

# Episode with metadata
episode = Episode(
    goal="Process order #5678",
    action="Validated payment, created shipment, sent confirmation",
    result="Order successfully processed",
    reflection="Payment validation could be parallelized",
    metadata={
        "order_id": "5678",
        "amount": 149.99,
        "customer_tier": "premium"
    },
    tags=["order-processing", "premium-customer"]
)

# Chained episodes (parent-child relationship)
parent = Episode(
    goal="Complete multi-step workflow",
    action="Initiated workflow",
    result="Workflow started"
)

child = Episode(
    goal="Execute step 1 of workflow",
    action="Performed data validation",
    result="Data validated successfully",
    parent_id=parent.id
)</code></pre>
                            </div>
                        </section>

                        <!-- MemoryStore -->
                        <section id="memory-store">
                            <h2>MemoryStore with FileAdapter</h2>
                            <p>
                                <code>MemoryStore</code> is the primary interface for storing and retrieving episodes. 
                                It uses pluggable adapters for different storage backends.
                            </p>

                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, MemoryStore, FileAdapter

# Simple initialization (uses file storage by default)
memory = Memory(agent_id="my-agent")

# Explicit adapter configuration
adapter = FileAdapter(
    base_path="./agent_memory",
    compression=True,          # Compress stored episodes
    max_file_size_mb=100       # Split into multiple files
)

memory = MemoryStore(
    agent_id="my-agent",
    adapter=adapter
)

# Store episodes
await memory.store(episode)

# Store with custom ID
await memory.store(episode, id="custom-id-123")

# Batch storage (more efficient)
episodes = [episode1, episode2, episode3]
await memory.store_batch(episodes)

# Retrieve by ID
episode = await memory.get("episode-id")

# Get recent episodes
recent = await memory.get_recent(limit=10)

# Get episodes by time range
from datetime import datetime, timedelta
yesterday = datetime.now() - timedelta(days=1)
episodes = await memory.get_range(start=yesterday, end=datetime.now())

# Count episodes
total = await memory.count()
tagged = await memory.count(tags=["error"])</code></pre>
                            </div>

                            <h3>FileAdapter Options</h3>
                            <table class="aos-table">
                                <thead>
                                    <tr>
                                        <th>Option</th>
                                        <th>Type</th>
                                        <th>Default</th>
                                        <th>Description</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>base_path</code></td>
                                        <td>str</td>
                                        <td>"./memory"</td>
                                        <td>Directory for episode storage</td>
                                    </tr>
                                    <tr>
                                        <td><code>compression</code></td>
                                        <td>bool</td>
                                        <td>True</td>
                                        <td>Enable gzip compression</td>
                                    </tr>
                                    <tr>
                                        <td><code>max_file_size_mb</code></td>
                                        <td>int</td>
                                        <td>100</td>
                                        <td>Max size before file rotation</td>
                                    </tr>
                                    <tr>
                                        <td><code>index_embeddings</code></td>
                                        <td>bool</td>
                                        <td>True</td>
                                        <td>Build vector index for search</td>
                                    </tr>
                                </tbody>
                            </table>
                        </section>

                        <!-- Semantic Search -->
                        <section id="semantic-search">
                            <h2>Semantic Search</h2>
                            <p>
                                EMK provides powerful semantic search capabilities using vector embeddings. 
                                Find relevant past experiences even when exact keywords don't match.
                            </p>

                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, SearchOptions

memory = Memory(
    agent_id="support-agent",
    embedding_model="all-MiniLM-L6-v2"  # Default model
)

# Basic semantic search
results = await memory.search("customer asking for refund")

# Search with options
results = await memory.search(
    query="payment processing error",
    options=SearchOptions(
        limit=10,                    # Max results
        min_score=0.7,               # Minimum similarity threshold
        tags=["payment", "error"],   # Filter by tags
        time_range=(start, end),     # Filter by time
        include_metadata=True        # Include full metadata
    )
)

# Access results
for result in results:
    print(f"Score: {result.score}")
    print(f"Episode: {result.episode}")
    print(f"Similarity: {result.similarity}")

# Search specific fields only
results = await memory.search(
    query="database timeout",
    fields=["action", "result"]  # Only search these fields
)

# Hybrid search (semantic + keyword)
results = await memory.hybrid_search(
    semantic_query="user authentication issue",
    keyword_filter="OAuth",
    weights={"semantic": 0.7, "keyword": 0.3}
)</code></pre>
                            </div>

                            <h3>Custom Embedding Models</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, EmbeddingProvider

# Use OpenAI embeddings
memory = Memory(
    agent_id="my-agent",
    embedding_provider=EmbeddingProvider.OPENAI,
    embedding_model="text-embedding-3-small"
)

# Use custom embedding function
def custom_embedder(text: str) -> list[float]:
    # Your custom embedding logic
    return model.encode(text).tolist()

memory = Memory(
    agent_id="my-agent",
    embedding_fn=custom_embedder
)

# Disable embeddings (keyword search only)
memory = Memory(
    agent_id="my-agent",
    enable_embeddings=False
)</code></pre>
                            </div>
                        </section>

                        <!-- Time-Travel Debugging -->
                        <section id="time-travel">
                            <h2>Time-Travel Debugging</h2>
                            <p>
                                The <code>replay()</code> function enables time-travel debugging‚Äîreconstruct 
                                the exact state of an agent at any point in history.
                            </p>

                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, replay, ReplayOptions
from datetime import datetime

memory = Memory(agent_id="trading-agent")

# Replay to a specific timestamp
state = await replay(
    memory=memory,
    timestamp=datetime(2024, 1, 15, 14, 30, 0)
)

print(f"Episodes at that moment: {len(state.episodes)}")
print(f"Agent context: {state.context}")
print(f"Active goals: {state.active_goals}")

# Replay with step-by-step execution
async for step in replay(memory, timestamp, step_by_step=True):
    print(f"Step {step.index}: {step.episode.action}")
    print(f"State after: {step.state}")
    
    # Optionally pause and inspect
    if step.episode.tags and "error" in step.episode.tags:
        print(f"Error occurred: {step.episode.result}")
        break

# Replay a specific episode chain
chain = await memory.get_chain(episode_id="root-episode-id")
for episode in chain:
    print(f"{episode.timestamp}: {episode.action}")

# Compare two points in time
diff = await memory.diff(
    timestamp_a=datetime(2024, 1, 15, 10, 0),
    timestamp_b=datetime(2024, 1, 15, 14, 0)
)
print(f"Episodes added: {len(diff.added)}")
print(f"State changes: {diff.state_delta}")</code></pre>
                            </div>

                            <h3>Replay Options</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import ReplayOptions

options = ReplayOptions(
    include_metadata=True,      # Include episode metadata
    reconstruct_context=True,   # Rebuild agent context
    validate_hashes=True,       # Verify episode integrity
    stop_on_error=False,        # Continue past errors
    max_episodes=1000           # Limit for performance
)

state = await replay(memory, timestamp, options=options)

# Verify replay integrity
if state.integrity_verified:
    print("All episode hashes validated")
else:
    print(f"Integrity issues: {state.integrity_errors}")</code></pre>
                            </div>
                        </section>

                        <!-- Memory Compression -->
                        <section id="memory-compression">
                            <h2>Memory Compression (Sleep Cycle)</h2>
                            <p>
                                Like biological memory consolidation during sleep, EMK provides a 
                                <code>compress()</code> function that consolidates old memories, 
                                reducing storage while preserving important patterns.
                            </p>

                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, compress, CompressionStrategy

memory = Memory(agent_id="long-running-agent")

# Basic compression (default strategy)
result = await compress(memory)
print(f"Compressed {result.episodes_processed} episodes")
print(f"Storage reduced: {result.storage_saved_mb} MB")
print(f"Summaries created: {len(result.summaries)}")

# Compression with custom strategy
result = await compress(
    memory=memory,
    strategy=CompressionStrategy.SEMANTIC_CLUSTERING,
    options={
        "min_age_days": 30,         # Only compress episodes older than 30 days
        "preserve_tags": ["error", "critical"],  # Never compress these
        "cluster_threshold": 0.85,  # Similarity threshold for clustering
        "summary_model": "gpt-4"    # LLM for generating summaries
    }
)

# View compression summaries
for summary in result.summaries:
    print(f"Summary: {summary.content}")
    print(f"Covers {summary.episode_count} episodes")
    print(f"Time range: {summary.start} to {summary.end}")

# Schedule automatic compression (sleep cycle)
memory.enable_sleep_cycle(
    schedule="0 3 * * *",  # Run at 3 AM daily
    strategy=CompressionStrategy.IMPORTANCE_WEIGHTED,
    notify_on_complete=True
)</code></pre>
                            </div>

                            <h3>Compression Strategies</h3>
                            <table class="aos-table">
                                <thead>
                                    <tr>
                                        <th>Strategy</th>
                                        <th>Description</th>
                                        <th>Best For</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>SEMANTIC_CLUSTERING</code></td>
                                        <td>Groups similar episodes into summaries</td>
                                        <td>Repetitive tasks</td>
                                    </tr>
                                    <tr>
                                        <td><code>IMPORTANCE_WEIGHTED</code></td>
                                        <td>Preserves high-impact episodes, summarizes routine ones</td>
                                        <td>Decision-heavy agents</td>
                                    </tr>
                                    <tr>
                                        <td><code>TIME_DECAY</code></td>
                                        <td>Progressively summarizes older memories</td>
                                        <td>Long-running agents</td>
                                    </tr>
                                    <tr>
                                        <td><code>HIERARCHICAL</code></td>
                                        <td>Creates summary hierarchies (day ‚Üí week ‚Üí month)</td>
                                        <td>Analytics and reporting</td>
                                    </tr>
                                </tbody>
                            </table>
                        </section>

                        <!-- Negative Memory -->
                        <section id="negative-memory">
                            <h2>Negative Memory (Anti-Patterns)</h2>
                            <p>
                                Negative memory records failures and anti-patterns‚Äîactions that should be 
                                avoided. This enables agents to learn from mistakes without repeating them.
                            </p>

                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, Episode, NegativeMemory

memory = Memory(agent_id="code-review-agent")

# Record a negative episode (mistake)
negative_episode = Episode(
    goal="Deploy to production",
    action="Deployed without running tests",
    result="Production outage for 2 hours",
    reflection="ALWAYS run tests before deployment",
    tags=["negative", "deployment", "critical"]
)

await memory.store_negative(negative_episode)

# Check for anti-patterns before acting
async def before_action(proposed_action: str):
    warnings = await memory.check_anti_patterns(proposed_action)
    
    for warning in warnings:
        print(f"‚ö†Ô∏è Warning: Similar action caused issues")
        print(f"   Past action: {warning.episode.action}")
        print(f"   Result: {warning.episode.result}")
        print(f"   Similarity: {warning.score}")
    
    return len(warnings) == 0  # Safe to proceed?

# Query negative memories specifically
failures = await memory.search(
    query="deployment failure",
    memory_type="negative"
)

# Get anti-pattern summary
anti_patterns = await memory.get_anti_patterns(
    category="deployment",
    min_occurrences=2  # Patterns that happened at least twice
)

for pattern in anti_patterns:
    print(f"Anti-pattern: {pattern.description}")
    print(f"Occurrences: {pattern.count}")
    print(f"Suggested avoidance: {pattern.recommendation}")</code></pre>
                            </div>

                            <h3>Automatic Anti-Pattern Detection</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, AntiPatternDetector

memory = Memory(agent_id="my-agent")

# Enable automatic detection
detector = AntiPatternDetector(
    memory=memory,
    detection_threshold=0.8,     # Similarity threshold
    min_failures=2,              # Minimum failures to flag
    auto_tag=True                # Automatically tag negative episodes
)

# The detector monitors new episodes
@detector.on_pattern_detected
async def handle_pattern(pattern):
    print(f"New anti-pattern detected: {pattern.description}")
    # Send alert, update policies, etc.

# Manual analysis
patterns = await detector.analyze(
    time_range=(start_date, end_date),
    categories=["api-calls", "data-processing"]
)</code></pre>
                            </div>
                        </section>

                        <!-- Storage Backends -->
                        <section id="storage-backends">
                            <h2>Storage Backends</h2>
                            <p>
                                EMK supports multiple storage backends through a unified adapter interface.
                            </p>

                            <h3>File Storage (Default)</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, FileAdapter

adapter = FileAdapter(
    base_path="./agent_memory",
    format="jsonl",          # or "parquet" for analytics
    compression="gzip",
    partition_by="day"       # Organize files by day
)

memory = Memory(agent_id="my-agent", adapter=adapter)</code></pre>
                            </div>

                            <h3>SQLite</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, SQLiteAdapter

adapter = SQLiteAdapter(
    database="./agent_memory.db",
    enable_fts=True,         # Full-text search
    enable_vector=True,      # Vector similarity (sqlite-vss)
    wal_mode=True            # Write-ahead logging
)

memory = Memory(agent_id="my-agent", adapter=adapter)

# SQLite-specific: direct SQL queries
results = adapter.execute("""
    SELECT * FROM episodes 
    WHERE json_extract(metadata, '$.severity') = 'critical'
    ORDER BY timestamp DESC
    LIMIT 10
""")</code></pre>
                            </div>

                            <h3>PostgreSQL</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os.emk import Memory, PostgresAdapter

adapter = PostgresAdapter(
    connection_string="postgresql://user:pass@localhost/agentdb",
    schema="emk",
    enable_pgvector=True,    # pgvector for semantic search
    pool_size=10
)

memory = Memory(agent_id="my-agent", adapter=adapter)

# PostgreSQL-specific: use pgvector operators
results = await adapter.vector_search(
    embedding=query_embedding,
    limit=10,
    filter={"agent_id": "my-agent"}
)</code></pre>
                            </div>

                            <h3>Backend Comparison</h3>
                            <table class="aos-table">
                                <thead>
                                    <tr>
                                        <th>Backend</th>
                                        <th>Best For</th>
                                        <th>Semantic Search</th>
                                        <th>Scalability</th>
                                    </tr>
                                </thead>
                                <tbody>
                                    <tr>
                                        <td><code>FileAdapter</code></td>
                                        <td>Development, single agent</td>
                                        <td>In-memory index</td>
                                        <td>Limited</td>
                                    </tr>
                                    <tr>
                                        <td><code>SQLiteAdapter</code></td>
                                        <td>Local deployment, moderate scale</td>
                                        <td>sqlite-vss</td>
                                        <td>Medium</td>
                                    </tr>
                                    <tr>
                                        <td><code>PostgresAdapter</code></td>
                                        <td>Production, multi-agent</td>
                                        <td>pgvector</td>
                                        <td>High</td>
                                    </tr>
                                </tbody>
                            </table>
                        </section>

                        <!-- KernelSpace Integration -->
                        <section id="kernel-integration">
                            <h2>Integration with KernelSpace</h2>
                            <p>
                                EMK integrates seamlessly with KernelSpace for automatic memory capture 
                                and policy-based memory management.
                            </p>

                            <div class="aos-code-block">
                                <pre><code>from agent_os import KernelSpace
from agent_os.emk import Memory, MemoryPolicy

# Initialize kernel with EMK
kernel = KernelSpace(
    policy="strict",
    memory=Memory(agent_id="governed-agent")
)

# Automatic episode capture for all registered functions
@kernel.register
async def process_order(order_id: str):
    # EMK automatically captures:
    # - Goal: "Execute process_order"
    # - Action: Function execution details
    # - Result: Return value or exception
    # - Reflection: Auto-generated based on outcome
    
    result = await do_processing(order_id)
    return result

# Memory-aware policies
memory_policy = MemoryPolicy(
    retention_days=365,              # Keep episodes for 1 year
    auto_compress_after_days=30,     # Compress after 30 days
    required_fields=["goal", "result"],
    max_episode_size_kb=100
)

kernel.add_policy(memory_policy)

# Access memory from kernel context
@kernel.register
async def smart_agent(task: str):
    # Search past experiences
    similar = await kernel.memory.search(task)
    
    if similar:
        # Use past experience to inform decision
        best_approach = similar[0].episode.reflection
        print(f"Learning from past: {best_approach}")
    
    # Execute with enhanced context
    return await execute_with_context(task, similar)

# Flight recorder integration
kernel.flight_recorder.on_episode(lambda ep: 
    print(f"Episode recorded: {ep.id}")
)

# Export memory for analysis
await kernel.memory.export(
    format="parquet",
    path="./memory_export.parquet",
    time_range=(start, end)
)</code></pre>
                            </div>

                            <h3>Cross-Module Integration</h3>
                            <div class="aos-code-block">
                                <pre><code>from agent_os import KernelSpace
from agent_os.emk import Memory
from agent_os.cmvk import verify
from agent_os.iatp import Identity

kernel = KernelSpace()
memory = Memory(agent_id="secure-agent")
identity = Identity.create("secure-agent")

@kernel.register
async def verified_action(task: str):
    # Check memory for anti-patterns
    warnings = await memory.check_anti_patterns(task)
    if warnings:
        return {"blocked": True, "reason": "Anti-pattern detected"}
    
    # Verify decision with CMVK
    decision = await verify(
        prompt=f"Should I: {task}",
        models=["gpt-4", "claude-3"],
        threshold=0.9
    )
    
    # Record episode with cryptographic signature
    episode = Episode(
        goal=task,
        action=f"Decision: {decision.result}",
        result=f"Consensus: {decision.confidence}",
        reflection="Verified multi-model decision",
        signature=identity.sign(decision.result)
    )
    
    await memory.store(episode)
    return decision.result</code></pre>
                            </div>
                        </section>

                        <!-- Navigation -->
                        <div style="display: flex; justify-content: space-between; margin-top: var(--space-2xl); padding-top: var(--space-xl); border-top: 1px solid var(--border-color);">
                            <a href="../cmvk/index.html" class="aos-btn-secondary">‚Üê CMVK Module</a>
                            <a href="../iatp/index.html" class="aos-btn-primary">IATP Module ‚Üí</a>
                        </div>
                    </div>
                </div>
            </div>
        </section>
    </main>

    <!-- Footer -->
    <footer class="aos-footer">
        <div class="container">
            <div class="aos-footer-grid">
                <div class="aos-footer-brand">
                    <h4>Agent OS</h4>
                    <p>The Linux kernel for AI agents. Deterministic safety enforcement.</p>
                    <p class="aos-footer-version">v0.1.0 ‚Ä¢ MIT License</p>
                </div>
                
                <div class="aos-footer-section">
                    <h5>Documentation</h5>
                    <ul>
                        <li><a href="../../docs/quickstart.html">Quickstart</a></li>
                        <li><a href="../../docs/api.html">API Reference</a></li>
                        <li><a href="../../docs/policies.html">Policies</a></li>
                        <li><a href="../index.html">Modules</a></li>
                    </ul>
                </div>
                
                <div class="aos-footer-section">
                    <h5>Resources</h5>
                    <ul>
                        <li><a href="../../integrations/index.html">Integrations</a></li>
                        <li><a href="../../use-cases/index.html">Use Cases</a></li>
                        <li><a href="../../examples/index.html">Examples</a></li>
                        <li><a href="https://github.com/imran-siddique/agent-os" target="_blank">GitHub</a></li>
                    </ul>
                </div>
                
                <div class="aos-footer-section">
                    <h5>Connect</h5>
                    <ul>
                        <li><a href="https://github.com/imran-siddique" target="_blank">GitHub</a></li>
                        <li><a href="https://linkedin.com/in/imransiddique1986" target="_blank">LinkedIn</a></li>
                        <li><a href="https://twitter.com/mosiddi" target="_blank">Twitter</a></li>
                        <li><a href="https://pypi.org/project/agent-os-kernel/" target="_blank">PyPI</a></li>
                    </ul>
                </div>
            </div>
            
            <div class="aos-footer-bottom">
                <p>&copy; 2026 Imran Siddique. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="../../../script.js"></script>
</body>
</html>
